{"abi":[{"type":"function","name":"createAndInitializePoolIfNecessary","inputs":[{"name":"token0","type":"address","internalType":"address"},{"name":"token1","type":"address","internalType":"address"},{"name":"fee","type":"uint24","internalType":"uint24"},{"name":"sqrtPriceX96","type":"uint160","internalType":"uint160"}],"outputs":[{"name":"pool","type":"address","internalType":"address"}],"stateMutability":"payable"}],"bytecode":{"object":"0x","sourceMap":"","linkReferences":{}},"deployedBytecode":{"object":"0x","sourceMap":"","linkReferences":{}},"methodIdentifiers":{"createAndInitializePoolIfNecessary(address,address,uint24,uint160)":"13ead562"},"rawMetadata":"{\"compiler\":{\"version\":\"0.8.19+commit.7dd6d404\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"uint160\",\"name\":\"sqrtPriceX96\",\"type\":\"uint160\"}],\"name\":\"createAndInitializePoolIfNecessary\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"createAndInitializePoolIfNecessary(address,address,uint24,uint160)\":{\"details\":\"This method can be bundled with others via IMulticall for the first action (e.g. mint) performed against a pool\",\"params\":{\"fee\":\"The fee amount of the v3 pool for the specified token pair\",\"sqrtPriceX96\":\"The initial square root price of the pool as a Q64.96 value\",\"token0\":\"The contract address of token0 of the pool\",\"token1\":\"The contract address of token1 of the pool\"},\"returns\":{\"pool\":\"Returns the pool address based on the pair of tokens and fee, will return the newly created pool address if necessary\"}}},\"title\":\"Creates and initializes V3 Pools\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"createAndInitializePoolIfNecessary(address,address,uint24,uint160)\":{\"notice\":\"Creates a new pool if it does not exist, then initializes if not initialized\"}},\"notice\":\"Provides a method for creating and initializing a pool, if necessary, for bundling with other methods that require the pool to exist.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"lib/uniswap/v3-periphery/contracts/interfaces/IPoolInitializer.sol\":\"IPoolInitializer\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[\":@openzeppelin/=lib/openzeppelin-contracts/\",\":@uniswap/v3-core/=lib/uniswap/v3-core/\",\":@uniswap/v3-periphery/=lib/uniswap/v3-periphery/\",\":ds-test/=lib/forge-std/lib/ds-test/src/\",\":erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\":forge-ctf/=lib/forge-ctf/src/\",\":forge-std/=lib/forge-std/src/\",\":openzeppelin-contracts/=lib/openzeppelin-contracts/\",\":openzeppelin/=lib/openzeppelin-contracts/contracts/\",\":uniswap/=lib/uniswap/\"]},\"sources\":{\"lib/uniswap/v3-periphery/contracts/interfaces/IPoolInitializer.sol\":{\"keccak256\":\"0x9d7695e8d94c22cc5fcced602017aabb988de89981ea7bee29ea629d5328a862\",\"license\":\"GPL-2.0-or-later\",\"urls\":[\"bzz-raw://61b50933026ee1017db2a6273af8cedc3238c95dca58880db0918dbdbb2f064f\",\"dweb:/ipfs/QmUebR26pqG25d18aBELKz8aFFKkmHa8PxntzXTA7o9Ldu\"]}},\"version\":1}","metadata":{"compiler":{"version":"0.8.19+commit.7dd6d404"},"language":"Solidity","output":{"abi":[{"inputs":[{"internalType":"address","name":"token0","type":"address"},{"internalType":"address","name":"token1","type":"address"},{"internalType":"uint24","name":"fee","type":"uint24"},{"internalType":"uint160","name":"sqrtPriceX96","type":"uint160"}],"stateMutability":"payable","type":"function","name":"createAndInitializePoolIfNecessary","outputs":[{"internalType":"address","name":"pool","type":"address"}]}],"devdoc":{"kind":"dev","methods":{"createAndInitializePoolIfNecessary(address,address,uint24,uint160)":{"details":"This method can be bundled with others via IMulticall for the first action (e.g. mint) performed against a pool","params":{"fee":"The fee amount of the v3 pool for the specified token pair","sqrtPriceX96":"The initial square root price of the pool as a Q64.96 value","token0":"The contract address of token0 of the pool","token1":"The contract address of token1 of the pool"},"returns":{"pool":"Returns the pool address based on the pair of tokens and fee, will return the newly created pool address if necessary"}}},"version":1},"userdoc":{"kind":"user","methods":{"createAndInitializePoolIfNecessary(address,address,uint24,uint160)":{"notice":"Creates a new pool if it does not exist, then initializes if not initialized"}},"version":1}},"settings":{"remappings":["@openzeppelin/=lib/openzeppelin-contracts/","@uniswap/v3-core/=lib/uniswap/v3-core/","@uniswap/v3-periphery/=lib/uniswap/v3-periphery/","ds-test/=lib/forge-std/lib/ds-test/src/","erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/","forge-ctf/=lib/forge-ctf/src/","forge-std/=lib/forge-std/src/","openzeppelin-contracts/=lib/openzeppelin-contracts/","openzeppelin/=lib/openzeppelin-contracts/contracts/","uniswap/=lib/uniswap/"],"optimizer":{"enabled":true,"runs":200},"metadata":{"bytecodeHash":"ipfs"},"compilationTarget":{"lib/uniswap/v3-periphery/contracts/interfaces/IPoolInitializer.sol":"IPoolInitializer"},"evmVersion":"paris","libraries":{}},"sources":{"lib/uniswap/v3-periphery/contracts/interfaces/IPoolInitializer.sol":{"keccak256":"0x9d7695e8d94c22cc5fcced602017aabb988de89981ea7bee29ea629d5328a862","urls":["bzz-raw://61b50933026ee1017db2a6273af8cedc3238c95dca58880db0918dbdbb2f064f","dweb:/ipfs/QmUebR26pqG25d18aBELKz8aFFKkmHa8PxntzXTA7o9Ldu"],"license":"GPL-2.0-or-later"}},"version":1},"id":50}